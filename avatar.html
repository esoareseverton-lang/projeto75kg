<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Avatar Evolução — Definitivo (Masculino & Feminino)</title>

  <style>
    :root{ --bg:#071124; --card:#0b1220; --muted:#9fb0c6; }
    html,body{ height:100%; margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial; color:#e6eef8; background:linear-gradient(180deg,#071124,#04101a); }
    .wrap{ max-width:1200px; margin:20px auto; padding:16px; display:grid; grid-template-columns:1fr 360px; gap:16px; }
    .card{ background:var(--card); padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,0.05); box-shadow:0 8px 28px rgba(0,0,0,0.5); }
    h1{ margin:0 0 6px; font-size:18px; }
    p.muted{ margin:0 0 10px; font-size:13px; color:var(--muted); }
    #viewport{ width:100%; height:620px; border-radius:10px; background:#050b18; overflow:hidden; position:relative; }
    .status{ position:absolute; left:10px; bottom:10px; background:rgba(0,0,0,0.45); padding:6px 10px; border-radius:6px; font-size:13px; color:#dff; }
    label{ font-size:13px; color:var(--muted); display:block; margin-bottom:4px; }
    input, select, button { width:100%; padding:8px; border-radius:8px; background:transparent; border:1px solid rgba(255,255,255,0.08); color:white; margin-bottom:10px; }
    .small { width:auto; display:inline-block; padding:8px 10px; margin-right:8px; }
    .btn-primary{ background:linear-gradient(90deg,#06b6d4,#10b981); color:#021015; border:none; }
    .btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.08); color:var(--muted); }
    .history{ max-height:380px; overflow-y:auto; display:flex; flex-direction:column; gap:6px; margin-top:10px; }
    .histItem{ padding:8px; background:rgba(255,255,255,0.04); border-radius:8px; font-size:13px; color:var(--muted); }
    footer{ margin-top:14px; text-align:center; font-size:12px; color:var(--muted); }
    .controls-row{ display:flex; gap:8px; align-items:center; }
    .preview{ display:flex; gap:8px; align-items:center; }
    .preview img{ width:100%; max-width:360px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); }
    @media(max-width:900px){ .wrap{ grid-template-columns:1fr; } #viewport{ height:420px; } }
  </style>

  <!-- importmap para three.js (resolve 'three' em exemplos/jsm) -->
  <script type="importmap">
  {"imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js" }}
  </script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Avatar Evolução — Visualização Definitiva</h1>
      <p class="muted">Mesmo avatar em 3 estágios (gordinho → magro → musculoso). Escolha Masculino ou Feminino, ajuste medidas e salve.</p>

      <div id="viewport">
        <div id="status" class="status">Status: pronto</div>
      </div>

      <div style="display:flex;gap:8px;margin-top:12px">
        <select id="sexSelect" class="small">
          <option value="male">Masculino</option>
          <option value="female">Feminino</option>
        </select>

        <button id="btnResetPose" class="small btn-ghost">Reset pose</button>
        <button id="btnRandomize" class="small btn-ghost">Randomizar medidas</button>
        <button id="btnSave" class="small btn-primary">Salvar pesagem</button>
      </div>

      <div style="margin-top:12px;display:grid;grid-template-columns:repeat(3,1fr);gap:10px">
        <div><label>Peso Atual (kg)</label><input id="w" type="number" step="0.1" value="95"></div>
        <div><label>Altura (m)</label><input id="h" type="number" step="0.01" value="1.70"></div>
        <div><label>Meta (kg)</label><input id="t" type="number" step="0.1" value="75"></div>
      </div>

      <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px">
        <div><label>Braço</label><input id="arm" type="number" step="0.1" value="35"></div>
        <div><label>Peito</label><input id="chest" type="number" step="0.1" value="110"></div>
        <div><label>Barriga</label><input id="waist" type="number" step="0.1" value="105"></div>
        <div><label>Coxa</label><input id="thigh" type="number" step="0.1" value="60"></div>
      </div>

      <div style="margin-top:12px">
        <div style="display:flex;justify-content:space-between">
          <strong>Progresso</strong><span id="percent" style="color:var(--muted)">0%</span>
        </div>
        <div style="height:14px;background:rgba(255,255,255,0.06);border-radius:999px;margin-top:6px;overflow:hidden">
          <div id="bar" style="height:100%;width:0%;background:linear-gradient(90deg,#ffb86b,#ff6b6b);transition:width .6s"></div>
        </div>
      </div>

      <div style="margin-top:12px" class="preview">
        <!-- preview estática que você aprovou (se você quiser a imagem embutida remova o src para evitar base64 enorme) -->
        <img src="" alt="Preview do avatar nos 3 estágios" id="approvedPreview">
        <div style="flex:1">
          <p class="muted">Preview estático — abaixo está a versão interativa que será usada para deformar o mesmo avatar entre os estágios. Clique em "Salvar pesagem" para ver contornos (ghosts) do estado atual ao lado.</p>
        </div>
      </div>

    </div>

    <div class="card">
      <h1>Histórico / Contornos</h1>
      <p class="muted">Cada pesagem salva cria um contorno do avatar naquele estado. Você pode selecionar e focar no contorno.</p>

      <div class="controls-row" style="margin-bottom:8px">
        <button id="btnExportCSV" class="btn-ghost small">Exportar CSV</button>
        <button id="btnClear" class="btn-ghost small">Limpar contornos</button>
      </div>

      <select id="weekSel" style="width:100%;padding:8px;margin-bottom:8px;border-radius:8px;background:#050b18;color:white;border:1px solid rgba(255,255,255,0.08)">
        <option value="">-- Selecione semana --</option>
      </select>

      <div id="history" class="history"></div>
      <footer>Entradas salvas: <span id="count">0</span></footer>
    </div>
  </div>
</body>
<script type="module">
/* ========= IMPORTS ========= */
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js";

/* ========= DOM references ========= */
const statusEl = document.getElementById('status');
const container = document.getElementById('viewport');
const bar = document.getElementById('bar');
const percentLabel = document.getElementById('percent');

const elW = document.getElementById('w');
const elH = document.getElementById('h');
const elT = document.getElementById('t');
const elArm = document.getElementById('arm');
const elChest = document.getElementById('chest');
const elWaist = document.getElementById('waist');
const elThigh = document.getElementById('thigh');

const sexSelect = document.getElementById('sexSelect');
const btnResetPose = document.getElementById('btnResetPose');
const btnRandomize = document.getElementById('btnRandomize');
const btnSave = document.getElementById('btnSave');

const historyDiv = document.getElementById('history');
const weekSel = document.getElementById('weekSel');
const countEl = document.getElementById('count');
const btnExportCSV = document.getElementById('btnExportCSV');
const btnClear = document.getElementById('btnClear');

const approvedPreview = document.getElementById('approvedPreview');

/* ========= set approved preview image (optional) =========
   If you have the preview PNG encoded as base64, you can paste it here as data URL:
   approvedPreview.src = 'data:image/png;base64,...'
   For brevity we leave it empty; you can set it later.
*/
approvedPreview.src = ""; // optional: set to the preview image data URL if you want

/* ========= three.js scene ========= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x071124);

const camera = new THREE.PerspectiveCamera(38, 1, 0.1, 100);
camera.position.set(0, 1.6, 6);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.maxPolarAngle = Math.PI / 2.1;

/* lighting */
const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,10,7); scene.add(dir);
const rim = new THREE.DirectionalLight(0xfff6e0, 0.12); rim.position.set(-5,2,-3); scene.add(rim);

/* ground plane (invisible) for reference */
const ground = new THREE.Mesh(new THREE.PlaneGeometry(40,40), new THREE.MeshStandardMaterial({ color:0x000000, opacity:0, transparent:true }));
ground.rotation.x = -Math.PI/2; scene.add(ground);

/* resize handling */
function resize(){
  const w = Math.max(320, container.clientWidth || 320);
  const h = Math.max(240, container.clientHeight || 240);
  renderer.setSize(w,h);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  controls.update();
}
window.addEventListener('resize', resize);
resize();

/* ========= Procedural stylized avatar =========
   We use a single procedural avatar (same object across stages) with grouped parts:
   - torsoGroup: scales for chest/waist (used to simulate belly/muscle)
   - arm groups, leg groups, head
   All deformations are local (scale/position) to keep the same model identity.
*/

/* Materials */
const skinMat = new THREE.MeshStandardMaterial({ color: 0xf2c9a6, roughness:0.7 });
const clothMat = new THREE.MeshStandardMaterial({ color: 0x2179ff, roughness:0.6 });
const shoeMat = new THREE.MeshStandardMaterial({ color: 0xd94b4b, roughness:0.5 });

/* Helper to create the stylized avatar variant */
function createStylizedAvatarVariant(sex='male'){
  const root = new THREE.Group();
  const sexScale = sex === 'female' ? 0.95 : 1.0;

  // torso group - used for chest/waist deformation
  const torsoGroup = new THREE.Group();
  torsoGroup.position.y = 0.8;
  const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.45, 0.48, 16, 32), clothMat);
  torsoGroup.add(torso);

  // head
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.28,32,32), skinMat);
  head.position.set(0,1.55,0);
  root.add(head);

  // eyes
  const eyeMat = new THREE.MeshStandardMaterial({ color:0x161616 });
  const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.06,12,12), eyeMat); eyeL.position.set(-0.08,1.58,0.24);
  const eyeR = eyeL.clone(); eyeR.position.x = 0.08;
  root.add(eyeL); root.add(eyeR);

  // mouth
  const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.03,0.02), new THREE.MeshStandardMaterial({color:0x7b2e2e}));
  mouth.position.set(0,1.48,0.24);
  root.add(mouth);

  // arms (groups so we can scale them)
  const armLGroup = new THREE.Group(); armLGroup.position.set(-0.52,0.95,0);
  const armRGroup = new THREE.Group(); armRGroup.position.set(0.52,0.95,0);
  const upperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.11,0.11,0.48,24), skinMat);
  upperArm.rotation.z = 0.12;
  armLGroup.add(upperArm);
  armRGroup.add(upperArm.clone());
  root.add(armLGroup); root.add(armRGroup);

  // hands
  const hand = new THREE.Mesh(new THREE.SphereGeometry(0.08,16,16), skinMat);
  hand.position.set(0,0.22,0);
  armLGroup.add(hand.clone()); armRGroup.add(hand.clone());

  // legs
  const legLGroup = new THREE.Group(); legLGroup.position.set(-0.18,0.18,0);
  const legRGroup = new THREE.Group(); legRGroup.position.set(0.18,0.18,0);
  const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.13,0.13,0.62,20), clothMat);
  legLGroup.add(thigh); legRGroup.add(thigh.clone());
  root.add(legLGroup); root.add(legRGroup);

  // shoes
  const shoe = new THREE.Mesh(new THREE.BoxGeometry(0.28,0.12,0.56), shoeMat);
  shoe.position.set(-0.18,-0.1,0.09); root.add(shoe.clone()); shoe.position.set(0.18,-0.1,0.09); root.add(shoe.clone());

  // attach torsoGroup to root
  root.add(torsoGroup);

  // store useful references for deformation
  root.userData = {
    torsoGroup, torsoMesh: torso,
    armLGroup, armRGroup,
    legLGroup, legRGroup,
    head, mouth, eyeL, eyeR,
    sex
  };

  root.scale.set(sexScale, sexScale, sexScale);
  return root;
}

/* instantiate main avatar used for all stages */
let mainAvatar = createStylizedAvatarVariant('male');
mainAvatar.position.set(0,0,0);
scene.add(mainAvatar);

/* container for ghost snapshots (wireframes of the same avatar) */
const ghostContainer = new THREE.Group();
scene.add(ghostContainer);

/* ========= deformation logic ========= */
/* This function maps the user measurements to local transformations of parts.
   - chest/waist -> scales torsoGroup
   - arm -> scales arm groups
   - thigh -> scales leg groups
   - height -> overall Y scale
   - head -> minor scaling to simulate chubby face
   All interpolations use .lerp to keep transitions smooth.
*/
function applyMeasuresToAvatar(avatar, measures){
  const ud = avatar.userData;
  if(!ud) return;
  const { torsoGroup, torsoMesh, armLGroup, armRGroup, legLGroup, legRGroup, head } = ud;

  // parse numbers (fault-tolerant)
  const height = Number(measures.height) || 1.75;
  const chest = Number(measures.chest) || 95;
  const waist = Number(measures.waist) || 90;
  const arm = Number(measures.arm) || 30;
  const thigh = Number(measures.thigh) || 50;

  // height -> vertical scale (subtle)
  const hScale = Math.max(0.8, Math.min(1.25, (height - 1.2) / 0.9));
  // apply to avatar's Y scale smoothly
  avatar.scale.y = hScale;

  // chest/waist mapping (tuned for stylized look)
  const chestScale = Math.max(0.8, Math.min(1.45, (chest - 70) / 50 + 1));
  const waistScale = Math.max(0.7, Math.min(1.6, (waist - 60) / 60 + 1));

  // target vector for torsoGroup scale: combine chest and waist in a pleasing way
  const targetTorso = new THREE.Vector3(chestScale * (waistScale*0.9), waistScale, chestScale * (waistScale*0.85));
  // smooth transition
  torsoGroup.scale.lerp(targetTorso, 0.2);

  // arms
  const armScale = Math.max(0.7, Math.min(1.6, arm / 30));
  armLGroup.scale.lerp(new THREE.Vector3(armScale, armScale, armScale), 0.2);
  armRGroup.scale.lerp(new THREE.Vector3(armScale, armScale, armScale), 0.2);

  // thighs
  const thighScale = Math.max(0.7, Math.min(1.6, thigh / 50));
  legLGroup.scale.lerp(new THREE.Vector3(thighScale, thighScale, thighScale), 0.2);
  legRGroup.scale.lerp(new THREE.Vector3(thighScale, thighScale, thighScale), 0.2);

  // head roundness (simulate chubby face via scale)
  const faceChubby = Math.max(0.9, Math.min(1.18, waistScale));
  head.scale.lerp(new THREE.Vector3(faceChubby, faceChubby, faceChubby), 0.1);
}

/* ========= Ghost creation (wireframe snapshots) ========= */
/* Creates a visual wireframe clone of the main avatar and positions it on the timeline */
function addGhost(measures, label){
  // clone the main avatar (deep-ish clone)
  const clone = mainAvatar.clone(true);
  // replace materials by wireframe basic
  clone.traverse(node => {
    if(node.isMesh){
      node.material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe:true, transparent:true, opacity:0.6 });
    }
  });
  // apply measures to the clone immediately so ghost captures the state
  applyMeasuresToAvatar(clone, measures);

  // position ghost in timeline to the right, with small zig-zag on z for visibility
  const idx = ghostContainer.children.length;
  const baseX = 2.8;
  const gap = 1.1;
  clone.position.set(baseX + idx * gap, 0, (idx % 2 === 0) ? -0.2 : 0.2);
  // scale ghosts down slightly
  clone.scale.multiplyScalar(0.85);
  ghostContainer.add(clone);

  // add history entry DOM
  const div = document.createElement('div'); div.className='histItem';
  div.textContent = (label || new Date().toLocaleString()) + ' — ' + (measures.weight || '') + 'kg';
  historyDiv.prepend(div);

  // store metadata in localStorage (simplified)
  const ghostsData = JSON.parse(localStorage.getItem('avatar_ghosts_v1') || '[]');
  ghostsData.unshift({ id:'g'+Date.now(), label: div.textContent, weight: measures.weight, date: new Date().toISOString(), measures });
  localStorage.setItem('avatar_ghosts_v1', JSON.stringify(ghostsData));
  refreshWeekSelect();
}

/* remove all ghosts */
function clearGhosts(){
  while(ghostContainer.children.length) ghostContainer.remove(ghostContainer.children[0]);
  localStorage.removeItem('avatar_ghosts_v1');
  historyDiv.innerHTML = '';
  refreshWeekSelect();
  setStatus('Contornos limpos');
}

/* ========= Progress calculation (same logic as before) ========= */
function updateProgress(){
  const ghostsData = JSON.parse(localStorage.getItem('avatar_ghosts_v1') || '[]');
  const initial = ghostsData.length ? ghostsData[ghostsData.length-1].weight : Number(elW.value);
  const current = Number(elW.value);
  const target = Number(elT.value);
  if(!initial || !current || !target){ bar.style.width='0%'; percentLabel.textContent='0%'; return; }
  let pct = 0;
  if(initial === target) pct = 100;
  else if(target < initial) pct = Math.min(100, Math.max(0, ((initial - current)/(initial - target))*100));
  else pct = Math.min(100, Math.max(0, ((current - initial)/(target - initial))*100));
  bar.style.width = pct + '%';
  percentLabel.textContent = Math.round(pct) + '%';
}

/* ========= UI handlers ========= */
btnRandomize.addEventListener('click', () => {
  elW.value = (Math.random()*30 + 60).toFixed(1);
  elH.value = (Math.random()*0.4 + 1.5).toFixed(2);
  elChest.value = (Math.random()*40 + 80).toFixed(1);
  elWaist.value = (Math.random()*40 + 70).toFixed(1);
  elArm.value = (Math.random()*20 + 25).toFixed(1);
  elThigh.value = (Math.random()*20 + 45).toFixed(1);
  applyMeasuresToAvatar(mainAvatar, { height:elH.value, chest:elChest.value, waist:elWaist.value, arm:elArm.value, thigh:elThigh.value });
  updateProgress();
  setStatus('Medidas randomizadas');
});

btnResetPose.addEventListener('click', () => {
  controls.reset();
  setStatus('Pose resetada');
});

btnSave.addEventListener('click', () => {
  const measures = {
    weight: Number(elW.value),
    height: Number(elH.value),
    chest: Number(elChest.value),
    waist: Number(elWaist.value),
    arm: Number(elArm.value),
    thigh: Number(elThigh.value)
  };
  addGhost(measures, new Date().toLocaleString());
  applyMeasuresToAvatar(mainAvatar, measures); // ensure main reflects new measures
  updateProgress();
  setStatus('Pesagem salva e contorno adicionado');
});

btnClear.addEventListener('click', () => clearGhosts());

btnExportCSV.addEventListener('click', () => {
  const ghostsData = JSON.parse(localStorage.getItem('avatar_ghosts_v1') || '[]');
  if(!ghostsData.length) return alert('Sem dados');
  const rows = ['id,label,weight,date'];
  ghostsData.forEach(g => rows.push([g.id, g.label, g.weight, g.date].join(',')));
  const blob = new Blob([rows.join('\n')], { type:'text/csv' });
  window.open(URL.createObjectURL(blob), '_blank');
});

/* sex selector re-creates the main avatar (keeps same identity but slightly different proportions) */
sexSelect.addEventListener('change', () => {
  const s = sexSelect.value;
  if(mainAvatar && mainAvatar.parent) scene.remove(mainAvatar);
  mainAvatar = createStylizedAvatarVariant(s);
  scene.add(mainAvatar);
  // apply current measures immediately
  applyMeasuresToAvatar(mainAvatar, { height:elH.value, chest:elChest.value, waist:elWaist.value, arm:elArm.value, thigh:elThigh.value });
  setStatus('Avatar trocado para ' + s);
});

/* select week focus: focuses camera on given ghost entry if exists */
weekSel.addEventListener('change', () => {
  const id = weekSel.value;
  const ghostsData = JSON.parse(localStorage.getItem('avatar_ghosts_v1') || '[]');
  const idx = ghostsData.findIndex(g => g.id === id);
  if(idx < 0) return;
  const ghostObject = ghostContainer.children[idx];
  if(ghostObject){
    const pos = new THREE.Vector3(); ghostObject.getWorldPosition(pos);
    camera.position.set(pos.x + 1.8, pos.y + 1.4, pos.z + 2.2);
    controls.target.copy(pos);
    controls.update();
  }
});

/* re-populate week select & history from localStorage on load */
function refreshWeekSelect(){
  const arr = JSON.parse(localStorage.getItem('avatar_ghosts_v1') || '[]');
  weekSel.innerHTML = '<option value="">-- Selecione semana --</option>';
  historyDiv.innerHTML = '';
  arr.forEach(item => {
    const opt = document.createElement('option'); opt.value = item.id; opt.textContent = item.label; weekSel.appendChild(opt);
    const div = document.createElement('div'); div.className='histItem'; div.textContent = item.label + ' — ' + item.weight + 'kg'; historyDiv.appendChild(div);
  });
  countEl.textContent = arr.length;
}

/* ========= Rendering loop ========= */
function setStatus(t){ statusEl.textContent = 'Status: ' + t; console.log('[status]', t); }
function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); }
animate();

/* apply initial measures and restore ghosts if any (note: visual ghosts aren't persisted as meshes) */
applyMeasuresToAvatar(mainAvatar, { height:elH.value, chest:elChest.value, waist:elWaist.value, arm:elArm.value, thigh:elThigh.value });
refreshWeekSelect();
updateProgress();
setStatus('Interativo — use os controles à esquerda.');
</script>
