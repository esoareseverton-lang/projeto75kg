<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Avatar Animado + Contornos de Evolu√ß√£o</title>
<style>
  :root{ --bg:#071124; --card:#0b1220; --muted:#9fb0c6; }
  html,body{ height:100%; margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial; color:#e6eef8; background:linear-gradient(180deg,#071124,#04101a); }
  .wrap{ max-width:1200px; margin:20px auto; padding:16px; display:grid; grid-template-columns:1fr 360px; gap:16px; }
  .card{ background:var(--card); padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,0.05); box-shadow:0 8px 28px rgba(0,0,0,0.5); }
  h1{ margin:0 0 6px; font-size:18px; }
  p.muted{ margin:0 0 10px; font-size:13px; color:var(--muted); }
  #viewport{ width:100%; height:620px; border-radius:10px; background:#050b18; overflow:hidden; position:relative; }
  .status{ position:absolute; left:10px; bottom:10px; background:rgba(0,0,0,0.45); padding:6px 10px; border-radius:6px; font-size:13px; color:#dff; }
  label{ font-size:13px; color:var(--muted); display:block; margin-bottom:4px; }
  input, select, button { width:100%; padding:8px; border-radius:8px; background:transparent; border:1px solid rgba(255,255,255,0.08); color:white; margin-bottom:10px; }
  .small { width:auto; display:inline-block; padding:8px 10px; margin-right:8px; }
  .btn-primary{ background:linear-gradient(90deg,#06b6d4,#10b981); color:#021015; border:none; }
  .btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.08); color:var(--muted); }
  .history{ max-height:380px; overflow-y:auto; display:flex; flex-direction:column; gap:6px; margin-top:10px; }
  .histItem{ padding:8px; background:rgba(255,255,255,0.04); border-radius:8px; font-size:13px; color:var(--muted); }
  footer{ margin-top:14px; text-align:center; font-size:12px; color:var(--muted); }
  .controls-row{ display:flex; gap:8px; align-items:center; }
  @media(max-width:900px){ .wrap{ grid-template-columns:1fr; } #viewport{ height:420px; } }
</style>
</head>
<body>

<div class="wrap">
  <!-- coluna principal: viewport 3D -->
  <div class="card">
    <h1>Avatar Animado ‚Äî com contornos de evolu√ß√£o</h1>
    <p class="muted">Clique em "Carregar modelo animado de teste". Salve pesagens para ver os contornos (wireframes) da evolu√ß√£o.</p>

    <div id="viewport">
      <div id="status" class="status">Status: pronto</div>
    </div>

    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="btnLoadTest" class="small btn-primary">Carregar modelo animado de teste</button>
      <button id="btnLoadFunny" class="small btn-ghost">Carregar modelo engra√ßado</button>
      <input id="customUrl" placeholder="URL direta para .glb (opcional)" style="flex:1" />
      <button id="btnLoadCustom" class="small btn-ghost">Carregar URL</button>
    </div>

    <div style="margin-top:12px;display:grid;grid-template-columns:repeat(3,1fr);gap:10px">
      <div><label>Peso Atual (kg)</label><input id="w" type="number" step="0.1" value="80"></div>
      <div><label>Altura (m)</label><input id="h" type="number" step="0.01" value="1.75"></div>
      <div><label>Meta (kg)</label><input id="t" type="number" step="0.1" value="75"></div>
    </div>

    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px">
      <div><label>Bra√ßo</label><input id="arm" type="number" step="0.1" value="30"></div>
      <div><label>Peito</label><input id="chest" type="number" step="0.1" value="95"></div>
      <div><label>Barriga</label><input id="waist" type="number" step="0.1" value="85"></div>
      <div><label>Coxa</label><input id="thigh" type="number" step="0.1" value="55"></div>
    </div>

    <div style="display:flex;gap:8px;margin-top:10px">
      <button id="btnSaveWeigh" class="btn-primary" style="flex:1">Salvar Pesagem (adiciona contorno)</button>
      <button id="btnSaveMeta" class="btn-ghost" style="flex:1">Salvar Meta</button>
      <button id="btnClearGhosts" class="btn-ghost" style="flex:1">Limpar contornos</button>
    </div>

    <div style="margin-top:12px">
      <div style="display:flex;justify-content:space-between">
        <strong>Progresso</strong><span id="percent" style="color:var(--muted)">0%</span>
      </div>
      <div style="height:14px;background:rgba(255,255,255,0.06);border-radius:999px;margin-top:6px;overflow:hidden">
        <div id="bar" style="height:100%;width:0%;background:linear-gradient(90deg,#ffb86b,#ff6b6b);transition:width .6s"></div>
      </div>
    </div>

  </div>

  <!-- coluna direita: hist√≥rico + a√ß√µes -->
  <div class="card">
    <h1>Hist√≥rico & Contornos</h1>
    <p class="muted">Cada pesagem salva adiciona um contorno (wireframe) para representar como voc√™ estava.</p>

    <div class="controls-row" style="margin-bottom:8px">
      <button id="btnExportCSV" class="btn-ghost small">Exportar CSV</button>
      <button id="btnToggleOutlineLabels" class="btn-ghost small">Mostrar r√≥tulos</button>
    </div>

    <select id="weekSel" style="width:100%;padding:8px;margin-bottom:8px;border-radius:8px;background:#050b18;color:white;border:1px solid rgba(255,255,255,0.08)">
      <option value="">-- Selecione semana --</option>
    </select>
    <div id="history" class="history"></div>
    <footer>Entradas salvas: <span id="count">0</span></footer>
  </div>
</div>

<!-- importmap para resolver 'three' nos exemplos -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js"
  }
}
</script>

<script type="module">
/* =========================
   Imports
   ========================= */
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js";

/* =========================
   Elementos DOM
   ========================= */
const statusEl = document.getElementById('status');
const container = document.getElementById('viewport');
const bar = document.getElementById('bar');
const percentLabel = document.getElementById('percent');

const elW = document.getElementById('w');
const elH = document.getElementById('h');
const elT = document.getElementById('t');
const elArm = document.getElementById('arm');
const elChest = document.getElementById('chest');
const elWaist = document.getElementById('waist');
const elThigh = document.getElementById('thigh');

const btnLoadTest = document.getElementById('btnLoadTest');
const btnLoadFunny = document.getElementById('btnLoadFunny');
const btnLoadCustom = document.getElementById('btnLoadCustom');
const customUrl = document.getElementById('customUrl');

const btnSaveWeigh = document.getElementById('btnSaveWeigh');
const btnSaveMeta = document.getElementById('btnSaveMeta');
const btnClearGhosts = document.getElementById('btnClearGhosts');

const historyDiv = document.getElementById('history');
const weekSel = document.getElementById('weekSel');
const countEl = document.getElementById('count');

const btnExportCSV = document.getElementById('btnExportCSV');
const btnToggleOutlineLabels = document.getElementById('btnToggleOutlineLabels');

/* =========================
   Three.js scene init
   ========================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x071124);

const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
camera.position.set(0, 1.6, 6);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.maxPolarAngle = Math.PI / 2.1;

/* ilumina√ß√£o suave e engra√ßada */
const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(5, 10, 7);
scene.add(dir);
const rim = new THREE.DirectionalLight(0xfff6e0, 0.12);
rim.position.set(-5, 2, -3);
scene.add(rim);

/* ground invis√≠vel para manter refer√™ncia de ch√£o */
const ground = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), new THREE.MeshStandardMaterial({ color: 0x000000, opacity: 0, transparent: true }));
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

/* resize handling */
function resize() {
  const w = Math.max(320, container.clientWidth || 320);
  const h = Math.max(240, container.clientHeight || 240);
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  controls.update();
}
window.addEventListener('resize', resize);
resize();

/* =========================
   Loader e anima√ß√µes
   ========================= */
const loader = new GLTFLoader();

// modelo animado de teste (funny/expressivo) ‚Äî proveniente de exemplos three.js (carrega sem CORS)
const TEST_MODEL = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/models/gltf/RobotExpressive/RobotExpressive.glb";
// outro modelo bem conhecido (rosto humano de exemplo) ‚Äî alternativo
const LEE_MODEL = "https://threejs.org/examples/models/gltf/LeePerrySmith/LeePerrySmith.glb";

/* refer√™ncias do modelo carregado + mixer para anima√ß√£o */
let baseScene = null;         // cena do gltf original
let mixer = null;            // AnimationMixer para o avatar principal
let clock = new THREE.Clock();

/* avatar principal (inst√¢ncia clonada do baseScene) */
let avatarMain = null;

/* lista de contornos/ghosts (cada ghost = { group, labelEl }) */
const ghosts = [];

/* flag para mostrar r√≥tulos nos contornos */
let showLabels = false;

/* helper: status vis√≠vel */
function setStatus(text, isError = false) {
  statusEl.textContent = "Status: " + text;
  statusEl.style.background = isError ? "rgba(120,10,10,0.6)" : "rgba(0,80,60,0.6)";
  console.log("[STATUS]", text);
}

/* =========================
   Carregar modelo GLB e retornar scene (com log)
   ========================= */
async function loadGLB(url) {
  setStatus("Carregando modelo...");
  try {
    const gltf = await new Promise((resolve, reject) => {
      loader.load(url, resolve, undefined, reject);
    });
    setStatus("Modelo carregado");
    return gltf.scene;
  } catch (err) {
    console.error("Erro ao carregar GLB:", err);
    setStatus("Falha ao carregar modelo ‚Äî veja console (F12).", true);
    return null;
  }
}

/* =========================
   Instancia o avatar principal (clona baseScene) e configura anima√ß√µes
   ========================= */
function instantiateMainAvatarFromScene(sceneRoot) {
  // remove anterior se existir
  if (avatarMain && avatarMain.parent) scene.remove(avatarMain);

  const inst = sceneRoot.clone(true);

  // clonar materiais para evitar conflito
  inst.traverse(node => {
    if (node.isMesh && node.material) node.material = node.material.clone();
  });

  // centro e ajuste
  const bbox = new THREE.Box3().setFromObject(inst);
  const yShift = bbox.min.y;
  // recentrar modelo na origem e colocar no ch√£o (y=0)
  const center = bbox.getCenter(new THREE.Vector3());
  inst.position.x -= center.x;
  inst.position.z -= center.z;
  inst.position.y -= yShift;

  // escala inicial confort√°vel
  inst.scale.set(1.0, 1.0, 1.0);

  // adicionar √† cena e guardar refer√™ncia
  avatarMain = inst;
  scene.add(avatarMain);

  // configurar mixer para anima√ß√µes (se o gltf carregado tem anima√ß√µes)
  mixer = null;
  // procurar anima√ß√µes na carga original via loader (n√£o recebemos clips aqui),
  // mas GLTFLoader as retorna junto ao objeto; para simplificar vamos tentar criar um mixer
  // e tocar todas as anima√ß√µes encontradas no gltf original ‚Äî se n√£o houver, n√£o faz nada.
  // OBS: Quando chamamos loadGLB usamos gltf.scene, mas perdemos clips ‚Äî para simplificar,
  // vamos recarregar via loader.load com callback que traz gltf.animations.
}

/* fun√ß√£o que carrega com clips e inicializa mixer (usa loader.load direto) */
function instantiateWithAnimations(url) {
  // removemos inst√¢ncias antigas
  if (avatarMain && avatarMain.parent) scene.remove(avatarMain);
  // carregar com callback para ter acesso a animations
  loader.load(url, (gltf) => {
    baseScene = gltf.scene;
    // clonar e adicionar
    const inst = gltf.scene.clone(true);
    inst.traverse(node => { if (node.isMesh && node.material) node.material = node.material.clone(); });
    // centralizar como antes
    const bbox = new THREE.Box3().setFromObject(inst);
    const center = bbox.getCenter(new THREE.Vector3());
    const yShift = bbox.min.y;
    inst.position.x -= center.x; inst.position.z -= center.z; inst.position.y -= yShift;
    inst.scale.set(1.0,1.0,1.0);
    scene.add(inst);
    avatarMain = inst;

    // mixer e tocar anima√ß√µes (se houver)
    if (gltf.animations && gltf.animations.length) {
      mixer = new THREE.AnimationMixer(inst);
      // vamos tocar a primeira anima√ß√£o principal ‚Äî loop infinito
      const action = mixer.clipAction(gltf.animations[0]);
      action.reset().play();
      // se houver mais, podemos alternar ou misturar ‚Äî aqui mantemos simples
    } else {
      mixer = null;
    }

    setStatus("Avatar animado carregado");
    console.log("Anima√ß√µes dispon√≠veis:", gltf.animations ? gltf.animations.length : 0);
  }, undefined, (err) => {
    console.error("Erro load com clips:", err);
    setStatus("Erro ao carregar anima√ß√£o (veja console)", true);
  });
}

/* =========================
   Criar um contorno (wireframe) baseado nas medidas atuais
   - clona o baseScene (ou avatarMain se tiver apenas primitives)
   - aplica material wireframe colorido e posi√ß√£o lateral
   - adiciona label DOM se showLabels = true
   ========================= */
function createGhostFromCurrent(measures, labelText) {
  // usamos avatarMain se tivermos um gltf; se n√£o, criamos um procedural simples
  let source = avatarMain;
  if (!source) {
    // fallback procedural group (bem simples)
    const fallback = new THREE.Group();
    const matSkin = new THREE.MeshStandardMaterial({ color: 0xf2c9a6 });
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 16), matSkin); head.position.set(0,1.45,0);
    fallback.add(head);
    source = fallback;
  }

  // clona a √°rvore e substitui materiais por wireframe
  const ghost = source.clone(true);
  ghost.traverse(node => {
    if (node.isMesh) {
      // material de contorno ‚Äî wireframe e semi-transparente
      node.material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.65 });
      node.renderOrder = 999; // desenha por cima
    }
  });

  // aplicar medidas (simples: escala por altura e largura do peito)
  const height = Number(measures.height) || 1.75;
  const chest = Number(measures.chest) || 95;
  const scaleH = Math.max(0.7, Math.min(1.3, ((height - 1.2) / 1.2) || 0.85));
  const scaleW = Math.max(0.75, Math.min(1.4, ((chest - 70) / 50 + 1) || 1));
  ghost.scale.set(scaleH * scaleW, scaleH * scaleW, scaleH * scaleW);

  // posicionar o ghost √† direita dos outros, em uma sequ√™ncia, calcule offset pela contagem atual
  const offsetIndex = ghosts.length;
  const baseX = 2.8; // dist√¢ncia do avatar principal
  const gap = 1.1;   // gap entre ghosts
  ghost.position.set(baseX + offsetIndex * gap, 0, (offsetIndex % 2 === 0) ? -0.2 : 0.2); // leve zig-zag

  // anima√ß√£o simples: come√ßar transparente pequeno -> aparecer e pulsar
  ghost.scale.multiplyScalar(0.6); // inicia menor, depois animamos para o target
  ghost.userData.targetScale = new THREE.Vector3(scaleH * scaleW, scaleH * scaleW, scaleH * scaleW);
  ghost.userData.growing = 0; // dado de anima√ß√£o

  scene.add(ghost);

  // label opcional (DOM) ‚Äî posiciona ao lado no painel (hist√≥rico) e tamb√©m pequena etiqueta 2D
  const id = "g" + Date.now();
  const div = document.createElement('div');
  div.className = 'histItem';
  div.textContent = `${labelText} ‚Äî ${measures.weight}kg`;
  div.dataset.ghostId = id;
  historyDiv.prepend(div); // adicionar no topo
  weekSel.innerHTML = `<option value="">-- Selecione semana --</option>`; // we'll regenerate list later

  // armazenar refer√™ncia para update loop
  ghosts.push({ id, group: ghost, dom: div });

  // atualizar contador e select
  countEl.textContent = ghosts.length;
  refreshWeekSelect();

  return ghost;
}

/* remove todos os ghosts da cena e limpa estado */
function clearGhosts() {
  ghosts.forEach(g => {
    if (g.group) scene.remove(g.group);
  });
  ghosts.length = 0;
  historyDiv.innerHTML = "";
  weekSel.innerHTML = `<option value="">-- Selecione semana --</option>`;
  countEl.textContent = 0;
  setStatus("Contornos limpos");
}

/* =========================
   Simples persist√™ncia local (localStorage)
   ========================= */
const STORAGE_GHOSTS = 'evo_ghosts_v1';
function saveGhostsLocal() {
  // salvamos apenas dados √∫teis (peso, height, chest, date, id)
  const data = ghosts.map(g => {
    const wg = g.group;
    return {
      id: g.id,
      weight: g.dom ? g.dom.textContent.split(' ‚Äî ')[1].replace('kg','') : null,
      date: Date.now()
    };
  });
  try { localStorage.setItem(STORAGE_GHOSTS, JSON.stringify(data)); } catch(e){ console.warn(e); }
}
function loadGhostsLocal() {
  try {
    const raw = JSON.parse(localStorage.getItem(STORAGE_GHOSTS) || '[]');
    return raw;
  } catch { return []; }
}

/* =========================
   UI: salvar pesagem -> cria ghost + atualiza progresso
   ========================= */
btnSaveWeigh.addEventListener('click', () => {
  const measures = {
    weight: parseFloat(elW.value) || 0,
    height: parseFloat(elH.value) || 1.75,
    chest: parseFloat(elChest.value) || 95,
    arm: parseFloat(elArm.value) || 30,
    thigh: parseFloat(elThigh.value) || 55
  };
  const label = new Date().toLocaleString();
  createGhostFromCurrent(measures, label);
  saveGhostsLocal();
  updateProgressBar();
  setStatus("Pesagem salva ‚Äî contorno adicionado üéâ");
});

/* salvar meta (atualiza barra) */
btnSaveMeta.addEventListener('click', () => {
  updateProgressBar();
  setStatus("Meta atualizada");
});

/* limpar ghosts */
btnClearGhosts.addEventListener('click', () => {
  clearGhosts();
});

/* export CSV (hist√≥rico simplificado) */
btnExportCSV.addEventListener('click', () => {
  if (!ghosts.length) { alert("Sem contornos/dados!"); return; }
  const rows = ["label,weight"];
  ghosts.forEach(g => rows.push(`${g.dom.textContent},${g.dom.textContent.split(' ‚Äî ')[1].replace('kg','')}`));
  const blob = new Blob([rows.join("\n")], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  window.open(url, "_blank");
});

/* Toggle labels */
btnToggleOutlineLabels.addEventListener('click', () => {
  showLabels = !showLabels;
  ghosts.forEach(g => { g.dom.style.display = showLabels ? 'block' : 'none'; });
});

/* semana select handler (focar um ghost quando selecionado) */
weekSel.addEventListener('change', () => {
  const id = weekSel.value;
  if (!id) {
    if (avatarMain) controls.target.set(0,1,0);
    return;
  }
  const found = ghosts.find(g => g.id === id);
  if (found) {
    // move camera to look at ghost
    const pos = new THREE.Vector3();
    found.group.getWorldPosition(pos);
    // animate camera quickly (simple set)
    camera.position.set(pos.x + 2.4, pos.y + 1.4, pos.z + 1.8);
    controls.target.copy(pos);
    controls.update();
  }
});

/* atualizar select com ghosts */
function refreshWeekSelect() {
  weekSel.innerHTML = `<option value="">-- Selecione semana --</option>`;
  ghosts.forEach(g => {
    const opt = document.createElement('option');
    opt.value = g.id;
    opt.textContent = g.dom.textContent;
    weekSel.appendChild(opt);
    // show/hide dom label according to toggle
    g.dom.style.display = showLabels ? 'block' : 'none';
  });
}

/* atualiza barra de progresso com base em peso atual e meta */
function updateProgressBar() {
  const initial = ghosts.length ? parseFloat(ghosts[0].dom.textContent.split(' ‚Äî ')[1].replace('kg','')) : parseFloat(elW.value);
  const current = parseFloat(elW.value);
  const target = parseFloat(elT.value);
  if (!initial || !current || !target) { bar.style.width = '0%'; percentLabel.textContent = '0%'; return; }
  // mesma l√≥gica do calcPercent anterior
  let pct = 0;
  if (initial === target) pct = 100;
  else if (target < initial) {
    pct = Math.min(100, Math.max(0, ((initial - current) / (initial - target)) * 100));
  } else {
    pct = Math.min(100, Math.max(0, ((current - initial) / (target - initial)) * 100));
  }
  bar.style.width = pct + "%";
  percentLabel.textContent = Math.round(pct) + "%";
}

/* =========================
   Animation loop: atualiza mixer e anima ghosts (crescer/pulsar)
   ========================= */
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  if (mixer) mixer.update(dt);

  // anima√ß√£o simples dos ghosts: crescimento at√© targetScale e leve pulsa√ß√£o
  ghosts.forEach((g, idx) => {
    const grp = g.group;
    if (!grp) return;
    // anima√ß√£o de "grow" at√© target
    if (grp.userData.growing < 1) {
      grp.userData.growing += dt * 1.2; // velocidade de crescimento
      const t = Math.min(1, grp.userData.growing);
      const target = grp.userData.targetScale || new THREE.Vector3(1,1,1);
      grp.scale.lerpVectors(new THREE.Vector3(0.6,0.6,0.6), target, t);
      // diminuir opacidade gradualmente (apagar um pouco com o tempo)
      grp.traverse(node => {
        if (node.isMesh && node.material && node.material.opacity !== undefined) {
          node.material.opacity = 0.65 * (0.6 + 0.4 * t); // 0.39..0.65
        }
      });
    } else {
      // pulsa√ß√£o sutil
      const pulse = 0.02 * Math.sin(performance.now() / 300 + idx);
      grp.scale.multiplyScalar(1 + pulse * dt * 6);
    }
  });

  renderer.render(scene, camera);
}
animate();

/* =========================
   Initial model loads / controls for test
   ========================= */
btnLoadTest.addEventListener('click', async () => {
  setStatus("Carregando modelo animado de teste...");
  // instanciamos com anima√ß√£o (usa loader.load com clips internamente)
  instantiateWithAnimations(TEST_MODEL);
});

btnLoadFunny.addEventListener('click', async () => {
  setStatus("Carregando modelo engra√ßado (alternativo)...");
  instantiateWithAnimations(LEE_MODEL);
});

btnLoadCustom.addEventListener('click', async () => {
  const url = customUrl.value.trim();
  if (!url) { alert("Cole a URL direta para um .glb no campo acima."); return; }
  setStatus("Carregando URL personalizada...");
  instantiateWithAnimations(url);
});

/* =========================
   Carregar ghosts salvos (se existirem) - simplificado
   ========================= */
(function loadSavedGhostsOnStart() {
  // aqui apenas restauramos a contagem visual; para simplicidade n√£o recriamos os meshes salvo em disco
  const saved = JSON.parse(localStorage.getItem('evo_ghosts_v1') || '[]');
  // reconstru√≠mos entradas no painel (sem mesh) ‚Äî user pode recriar manualmente salvando novamente
  saved.forEach(s => {
    const div = document.createElement('div');
    div.className = 'histItem';
    div.textContent = s.label + ' ‚Äî ' + (s.weight || '0') + 'kg';
    historyDiv.appendChild(div);
  });
  countEl.textContent = saved.length;
})();

/* =========================
   simplify: instantiateWithAnimations uses loader.load and sets mixer.
   (function defined earlier)
   ========================= */

/* tiny helper para centrar a c√¢mera no avatarMain depois de carregar */
function focusMainAvatar() {
  if (!avatarMain) return;
  const pos = new THREE.Vector3();
  avatarMain.getWorldPosition(pos);
  controls.target.copy(pos);
  camera.position.set(pos.x + 0.8, pos.y + 1.4, pos.z + 2.6);
  controls.update();
}

/* after model loads, try to focus */
setInterval(() => { if (avatarMain) focusMainAvatar(); }, 500);

/* =========================
   Observa√ß√µes finais (simples)
   - este exemplo usa um modelo animado (RobotExpressive) que j√° cont√©m anima√ß√µes engra√ßadas.
   - quando salvar pesagem, criamos contorno wireframe + label no painel.
   - para usar seus .glb definitivos, cole a URL no campo e clique "Carregar URL".
   ========================= */

</script>
</body>
</html>
